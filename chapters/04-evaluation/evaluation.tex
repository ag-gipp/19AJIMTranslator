\section{Evaluation}\label{sec:evaluation}
We implemented three approaches to evaluate whether a translation was \textit{appropriate} or \textit{inappropriate}.
\begin{enumerate}
\item \textbf{Round Trip Tests}: translates expressions back and forth and analyzing the changes.
\item\label{approach-2} \textbf{Function Relation Tests (Symbolical)}: translate mathematically proven equivalent expressions from one system to a \gls*{cas} and evaluate whether the relation remains valid via symbolical equivalence checks.
\item \textbf{Numerical Tests}: take the same equations from Approach~\ref{approach-2} but evaluates them on specific numerical values to test equivalence.
\end{enumerate}

\subsection{Round Trip Tests}\label{sec:round-trip}
A round trip test always starts with a valid expression either in semantic \LaTeX{} or in \Maple. A translation from one system to another is called \textbf{a step}. A complete round trip translation (two steps) is called \textbf{one cycle}. A \textbf{fixed point representation} (or short fixed point) in a round trip translation process is a string representation that is identical to all string representations in the following cycles.

Table~\ref{tab:fixpoint} illustrates an example of a round trip test which reaches a fixed point. The test formula is
\begin{equation}
\frac{\cos\left(a\Theta\right)}{2}.
\end{equation}

\begin{table}[ht]
\centering
\begin{tabular}{cc}
	\hline 
	Steps & semantic \LaTeX{}/\Maple{} representations\\
	\hline
	\rule{0pt}{0.9\normalbaselineskip}0 & \verb|\frac{\cos@{a\Theta}}{2}|\\
	1 & \verb|(cos(a*Theta))/(2)| \\
	2 & \verb|\frac{1}{2}\idot\cos@{a\idot\Theta}| \\
	3 & \verb|(1)/(2)*cos(a*Theta)|\\
	4 & \verb|\frac{1}{2}\idot\cos@{a\idot\Theta}| \\
	\hline
\end{tabular}
\caption{A round trip test reaching a fixed point.}
\label{tab:fixpoint}
\end{table}

Step 4 is identical to step 2, and since the translator is a deterministic algorithm it can be easily shown that step 2 and step 3 are fixed-point representations for semantic \LaTeX{} and \Maple.

There is currently only one exception known where a round trip test does not reach a fixed point representation: Legendre's incomplete elliptic integrals~\parencite[(19.2.4-7)]{NIST:DLMF} are defined with the amplitude $\phi$ in the first argument in the \DLMF, while \Maple{} takes the trigonometric sine of the amplitude as the first argument. Therefore, the forward and backward translations are defined as
\begin{eqnarray}
\verb|\EllIntF@{\phi}{k}| & \overset{\langMaple}{\mapsto} & \verb|EllipticF(sin(phi),k)|,\\
\verb|\EllIntF@{\asin@{\phi}}{k}| & \overset{\langMaple}{\mapsfrom} & \verb|EllipticF(phi,k)|,
\end{eqnarray}

The round-trip translations produce infinite chains of sine and inverse sine calls because there are no evaluations involved. 
The round trip tests are very successful, but they only detect errors in string representations. However, because of the simplification techniques of fixed points, we are able to at least detect logical errors in one system: \Maple. On the other hand, these tests cannot determine logical errors in the translations between the two systems. Consider we mistakenly defined an \textit{inappropriate} forward and backward translation for the sine function
\begin{eqnarray}
\verb|\sin@{\phi}| & \overset{\langMaple}{\leftrightarrow} & \verb|cos(phi)|,\label{eq:wrong-trans-1}\\
\verb|\cos@{\phi}| & \overset{\langMaple}{\leftrightarrow} & \verb|sin(phi)|.\label{eq:wrong-trans-2}
\end{eqnarray}
In that case the round trip test would not detect any errors and reach a fixed point representation, because the simplification techniques only simplify two representations in the same system but cannot compare the representation in one system to those in the other.

\subsection{Function Relation Tests}\label{sec:relation-tests}
The \gls*{dlmf} is a compendium of special functions and orthogonal polynomials and lists several relations between the functions and polynomials. The idea of this evaluation approach is to translate an entire relation and test whether the relation remains valid after performing the translations.

With this technique we can detect translation errors such as in \eqref{eq:wrong-trans-1} and \eqref{eq:wrong-trans-2}. Consider the \gls*{dlmf} equation for the sine and cosine function~\parencite[(4.21.2)]{NIST:DLMF}
\begin{equation}
\sin \left(u+v\right) = \sin{u}\cos{v} + \cos{u}\sin{v}.
\end{equation}
Assume the translator would forward translate the expression based on (\ref{eq:wrong-trans-1},~\ref{eq:wrong-trans-2}). Than
\begin{eqnarray}
\verb|\sin@{u + v}| & \overset{\langMaple}{\mapsto} & \verb|cos(u + v)|,\\
\verb|\sin@@{u}\cos@@{v}| & \overset{\langMaple}{\mapsto} & \verb|cos(u)*sin(v)|,\\
\verb|\cos@@{u}\sin@@{v}| & \overset{\langMaple}{\mapsto} & \verb|sin(u)*cos(v)|.
\end{eqnarray}
This produces the equation in \Maple
\begin{equation}
\cos\left(u+v\right) = \cos{u}\sin{v} + \sin{u}\cos{v},
\end{equation}
which is wrong. Since the expression is correct before the translation, we conclude an error during the translation process.

However, there are two essential problems with this approach. Testing the mathematical equivalence of expressions is hard to solve and \gls*{cas} have trouble to test even simple equations. Furthermore, this approach only checks forward translations because there is no way to check equivalence of expressions in \LaTeX{} automatically (again this could become feasible with our translator). We use \Maple's \textit{simplify} function to check if the difference of the left-hand side and the right-hand side of the equation is equal to zero. In addition, we use \textit{simplify} and check if the division of the right-hand side by the left-hand side returns a numerical value or not. This simplification function is the most powerful function to check the equivalence in \Maple. However, there are several cases where the simplification fails. Because of implementation details, there are some techniques that helps \Maple{} to find possible simplifications. For example we can force \Maple{} to convert the formula
\begin{equation}
\sinh{x} + \sin{x}
\end{equation}
to an equivalent representation using the exponential representations
\begin{equation}
\frac{1}{2}\expe^x - \frac{1}{2}\expe^{-x} - \frac{1}{2} \iunit \left( \expe^{\iunit x}-\expe^{-\iunit x} \right).
\end{equation}
With such pre-conversions we are able to improve the simplification process in \Maple. However, the limitations of the \textit{simplify} function are still the weakest part of this verification approach. Consider the complex example~\parencite[(12.7.10)]{NIST:DLMF}
\begin{equation}\label{eq:branch-cut-near}
\displaystyle U(0,z) = \sqrt{\frac{z}{2\cpi}} K_{\frac{1}{4}}\left(\frac{1}{4}z^2\right),
\end{equation}
where $U(0,z)$ is the parabolic cylinder function and $K_\nu(z)$ the modified Bessel function of the second kind. Both functions are well-defined in both systems and we can define a \textit{direct} translation for~\eqref{eq:branch-cut-near}. 
The modified Bessel function of the second kind has its branch cut in \Maple{} and in the \gls*{dlmf} at $z < 0$. However, the argument of $K$ contains $z^2$. If $|\ph{z}| \in \left(\frac{\cpi}{2}, \cpi\right)$ the value of the right-hand side of~\eqref{eq:branch-cut-near} would be no longer on the principal branch. However, \Maple{} will still compute the principal values independently of the value of $z$. Hence, a translation
\begin{equation}
\verb|\BesselK{\frac{1}{4}}@{\frac{1}{4}z^2}| \overset{\langMaple}{\mapsto} \verb|BesselK(1/4,(1/4)*z^2)|
\end{equation}
is incorrect if $|\ph{z}| \in \left(\frac{\cpi}{2}, \cpi\right)$ and one has to use analytic continuation for the right-hand side of equation (\ref{eq:branch-cut-near}). 

To evaluate such complex cases, the equivalence checks of \gls*{cas} are insufficient. Therefore we implement numerical tests as an additional step.

\subsection{Numerical Tests}\label{sec:numerical-tests}
Consider the differences of the left- and right-hand side of equation~\eqref{eq:branch-cut-near}
\begin{equation}\label{eq:difference}
D(z) := U(0,z) - \sqrt{\frac{z}{2\cpi}} K_{\frac{1}{4}}\left(\frac{1}{4}z^2\right).
\end{equation}
Table~\ref{tab:computations-for-difference} presents four computations for $D(z)$, one value for each quadrant in the complex plane.
\begin{table}[ht]
\centering
\begin{tabular}{rcc}
	\hline
	$z\ \ $ & & $D(z)$\\
	\hline
	\tableRowSpace{} $1+\iunit$ & & $2 \cdot 10^{-10} - 2 \cdot 10^{-10} \iunit$\\
	$-1+\iunit$& & $2.222121916 - 1.116719816 \iunit$\\
	$-1-\iunit$& & $2.222121916 + 1.116719816 \iunit$\\
	$1-\iunit$ & & $2 \cdot 10^{-10} + 2 \cdot 10^{-10} \iunit$\\
	\hline
\end{tabular}
\caption{Four computations of $D(z)$ in \Maple.}
\label{tab:computations-for-difference}
\end{table}

Considering machine accuracy and the default precision of $10$ significant digits, we can regard the first and last values as zero differences. While this evaluation is very powerful, it has a significant problem. Even when all tested values return zero, it does not proof the equivalence of~\eqref{eq:branch-cut-near}. However, when the values are different from zero, it does proof an error in one of the four cases~\parencite{NumericalTests:Paper}
\begin{enumerate}
\item the numerical engine tests invalid combinations of values;
\item the translation is incorrect;
\item there may be an error in the \gls*{dlmf} source; or
\item there may be an error in \Maple.
\end{enumerate}

\subsection{Results}\label{sec:test-summary}
There are 685 \Macro s\footnote{The macros are still work in progress, and therefore the total number is constantly changing.} in total, and 665 of them were implemented in the translator engine. We defined forward translations to \Maple{} for 201 and backward translations from \Maple{} for 195 functions. 

The \gls*{dlmf} provides a dataset of \LaTeX{} expressions with semantic macros. We extracted 4.087 equations from \gls*{dlmf} and apply our round-trip and relation tests on them. The translator was able to translate 2.405\footnote{All percentages are approximately calculated.} (58.8\%) of the extracted equations without errors. 660 (27.4\%) of the successfully translated expressions were verified by the simplification techniques of \Maple. We apply additional numerical tests for the remaining 1.745 equations. For 418 (24\%) cases the numerical tests were valid. More detailed results for numerical and symbolical tests were presented in~\parencite{NumericalTests:Paper}.

The evaluation techniques have proven to be very powerful also for evaluating \gls*{cas} and online mathematical compendia such as the \gls*{dlmf}. During the evaluations, we were able to detect several errors in the translation and evaluation engine, and also discovered two errors in the \gls*{dlmf} and one error in \Maple's \texttt{simplify}-function.

The numerical test engine was able to discover a sign error in equation~\parencite[(14.5.14)]{NIST:DLMF}\footnote{The equation had originally been stated as shown in equation~(\ref{eq:signerror}). The error were reported on 10th April 2017.}
\begin{equation}\label{eq:signerror}
\displaystyle \mathsf{Q}^{-1/2}_{\nu}\left(\cos\theta\right)=-\left(\frac{\pi}{2\sin\theta}\right)^{1/2}\frac{\cos\left(\left(\nu+\frac{1}{2}\right)\theta\right)}{\nu+\frac{1}{2}}.
\end{equation}
The error can be found on~\parencite[p. 359]{NIST:Handbook} and has been fixed in the \gls*{dlmf} with version 1.0.16. The same engine also identified a missing comma in the constraint of~\parencite[(10.16.7)]{NIST:DLMF}. The original constraint was given by $2\nu \neq -1, -2 -3, \ldots$, with a missing comma after $-2$.

We have also noticed that our testing procedure is able to identify errors in CAS procedures,
namely the \Maple{} {\tt simplify} procedure. The left-hand side of \cite[(7.18.4)]{NIST:DLMF} is given by 
\begin{equation*}
\frac{{\mathrm{d}}^{n}}{{\mathrm{d}z}^{n}}\left(e^{z^{2}}\operatorname{erfc}z\right),
\end{equation*}
where $n \in \mathbb{N}_0$, $e$ is the base of the natural logarithm, and $\operatorname{erfc}$ is the
complementary error function. Our translation correctly produces 
\begin{equation*}
\verb|diff((exp((z)^(2))*erfc(z)), [z$(n))]|.
\end{equation*}
However, the \Maple{ 2016} \verb|simplify| function falsely returns $0$ for the translated left-hand side.
Maplesoft has confirmed in a private communication that this is indeed a defect in \Maple{ 2016}.
Furthermore, although the nature of the defect changes, the defect still persists in \Maple{ 2018}
as of the publication of this manuscript.

